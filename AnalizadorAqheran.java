/* AnalizadorAqheran.java */
/* Generated By:JavaCC: Do not edit this line. AnalizadorAqheran.java */
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;

public class AnalizadorAqheran implements AnalizadorAqheranConstants {

    // Listas para errores y semántica
    static ArrayList<String> tabla = new ArrayList<String>();
    static ArrayList<String> erroresSemanticos = new ArrayList<String>();
    static TablaSimbolos tablaSimbolos = new TablaSimbolos();
    static PilaSemantica pilaSemantica = new PilaSemantica();

    public static void main(String[] args) {
        try {
            String contenido = new String(Files.readAllBytes(Paths.get(args[0])), StandardCharsets.UTF_8);
            if (contenido.startsWith("\ufeff")) {
                contenido = contenido.substring(1);
            }

            AnalizadorAqheran parser = new AnalizadorAqheran(new StringReader(contenido));
            Nodo raiz = parser.parse();

            if (raiz != null) {
                System.out.println("\n--- \u00c1RBOL DE SINTAXIS GENERADO ---");
                raiz.imprimir("", true);
                System.out.println("----------------------------------");

                List<String> cuadruplos = pilaSemantica.getCuadruplos();
                if (!cuadruplos.isEmpty()) {
                    System.out.println("\n--- C\u00d3DIGO INTERMEDIO (CU\u00c1DRUPLOS) ---");
                    System.out.println(String.format("%-5s %-10s %-10s %-10s", "OP", "ARG1", "ARG2", "RESULTADO"));
                    System.out.println("--------------------------------------------");
                    for (String c : cuadruplos) System.out.println(c);
                    System.out.println("--------------------------------------------");
                }
            }

        } catch (Exception e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }

    public Nodo parse() throws IOException {
        ArrayList<String> erroresLexicos = AnalizadorAqheranTokenManager.tablaErrores;
        Nodo raiz = null;

        try {
            raiz = principal();

            if (!erroresLexicos.isEmpty()) {
                System.out.println("\n** Errores LEXICOS encontrados: **");
                for (String err : erroresLexicos) System.out.println(err);
            } else {
                System.out.println("\n** Analisis LEXICO sin errores. **");
            }

            if (!tabla.isEmpty()) {
                System.out.println("\n** Errores SINTACTICOS encontrados: **");
                for (String err : tabla) System.out.println(err);
            } else {
                System.out.println("\n** Analisis SINTACTICO sin errores. **");
            }

            if (!erroresSemanticos.isEmpty()) {
                System.out.println("\n** Errores SEMANTICOS encontrados: **");
                for (String err : erroresSemanticos) System.out.println(err);
            } else {
                System.out.println("\n** Analisis SEMANTICO sin errores. **");
            }

        } catch (ParseException e) {
            tabla.add(manejarErrorSintactico(e));
        }
        return raiz;
    }

    static String manejarErrorSintactico(ParseException e) {
        String mensajeOriginal = e.getMessage();
        String mensajeTraducido = mensajeOriginal
            .replace("Encountered", "Encontrado")
            .replace("at line", "en la l\u00ednea")
            .replace("column", "columna")
            .replace("Was expecting:", "Se esperaba:")
            .replace("Was expecting one of:", "Se espera una de estas opciones:");

        return "Error Sintactico: " + mensajeTraducido;
    }

    // Auxiliar para comprobación de tipos
    static String verificarTipo(String t1, String t2, String op) {
        if (t1.equals("error") || t2.equals("error")) return "error";

        // Reglas de compatibilidad simples
        if (t1.equals(t2)) return t1;

        // Promoción de int a float
        if ((t1.equals("int") && t2.equals("float")) || (t1.equals("float") && t2.equals("int"))) {
            return "float";
        }

        erroresSemanticos.add("Error Semantico: Tipos incompatibles [" + t1 + "] y [" + t2 + "] para el operador '" + op + "'");
        return "error";
    }

// ==========================================
// ANALISIS SINTACTICO
// ==========================================
  static final public 
Nodo principal() throws ParseException {Nodo raiz = new Nodo("Programa"); Nodo hijo; Token t;
    try {
      jj_consume_token(INICIO);
      t = jj_consume_token(IDENTIFICADOR);
raiz.valor = "Programa: " + t.image;
      jj_consume_token(LLAVEIZQ);
      label_1:
      while (true) {
        hijo = Codigo();
raiz.agregarHijo(hijo);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BOOL:
        case VAR:
        case CONST:
        case FOR:
        case WHILE:
        case SI:
        case LEER:
        case ESCRIBIR:
        case VOID:
        case FUNC:
        case IDENTIFICADOR:{
          ;
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
      }
      jj_consume_token(LLAVEDER);
      jj_consume_token(FIN);
{if ("" != null) return raiz;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        Token tok;
        do {
            tok = getNextToken();
        } while (tok.kind != EOF && tok.kind != FIN);
        {if ("" != null) return raiz;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo Codigo() throws ParseException {Nodo n;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VAR:{
      n = declararVariable();
{if ("" != null) return n;}
      break;
      }
    case CONST:{
      n = declararConstante();
{if ("" != null) return n;}
      break;
      }
    case ESCRIBIR:{
      n = gramaticaEscribir();
{if ("" != null) return n;}
      break;
      }
    case LEER:{
      n = gramaticaLeer();
{if ("" != null) return n;}
      break;
      }
    case SI:{
      n = gramaticaSi();
{if ("" != null) return n;}
      break;
      }
    case WHILE:{
      n = gramaticaWhile();
{if ("" != null) return n;}
      break;
      }
    case IDENTIFICADOR:{
      n = gramaticaAsignacion();
{if ("" != null) return n;}
      break;
      }
    case FUNC:{
      n = llamarFuncion();
{if ("" != null) return n;}
      break;
      }
    case FOR:{
      n = gramaticaFor();
{if ("" != null) return n;}
      break;
      }
    case BOOL:{
      n = gramaticaOperadorLogico();
{if ("" != null) return n;}
      break;
      }
    case VOID:{
      n = SentenciasFunciones();
{if ("" != null) return n;}
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo declararVariable() throws ParseException {Token t; Nodo n = new Nodo("Declaracion Variable"); String tipo;
    try {
      jj_consume_token(VAR);
      t = jj_consume_token(IDENTIFICADOR);
      tipo = tipoDato();
      jj_consume_token(DELIMITADOR);
try {
                tablaSimbolos.insertar(t.image, tipo);
            } catch (Exception e) {
                erroresSemanticos.add(e.getMessage());
            }
            n.agregarHijo(new Nodo(t.image, tipo));
            {if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo declararConstante() throws ParseException {Token t; Nodo n = new Nodo("Declaracion Constante"); String tipo; Nodo v;
    try {
      jj_consume_token(CONST);
      t = jj_consume_token(IDENTIFICADOR);
      tipo = tipoDato();
      jj_consume_token(IGUAL);
      v = valor();
      jj_consume_token(DELIMITADOR);
try {
                tablaSimbolos.insertar(t.image, tipo);
                // Comprobar que el valor asignado sea compatible con el tipo declarado
                verificarTipo(tipo, v.tipo, "=");
            } catch (Exception e) {
                erroresSemanticos.add(e.getMessage());
            }
            Nodo c = new Nodo(t.image, tipo);
            c.agregarHijo(v);
            n.agregarHijo(c);
            {if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public String tipoDato() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INT:{
      t = jj_consume_token(INT);
{if ("" != null) return t.image;}
      break;
      }
    case FLOAT:{
      t = jj_consume_token(FLOAT);
{if ("" != null) return t.image;}
      break;
      }
    case BOOL:{
      t = jj_consume_token(BOOL);
{if ("" != null) return t.image;}
      break;
      }
    case STRING:{
      t = jj_consume_token(STRING);
{if ("" != null) return t.image;}
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo valor() throws ParseException {Token t; Nodo n;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ENTEROS:{
      t = jj_consume_token(ENTEROS);
n = new Nodo(t.image, "int"); pilaSemantica.push(n); {if ("" != null) return n;}
      break;
      }
    case VCAD:{
      t = jj_consume_token(VCAD);
n = new Nodo(t.image, "string"); pilaSemantica.push(n); {if ("" != null) return n;}
      break;
      }
    case NUMERODECIMAL:{
      t = jj_consume_token(NUMERODECIMAL);
n = new Nodo(t.image, "float"); pilaSemantica.push(n); {if ("" != null) return n;}
      break;
      }
    case IDENTIFICADOR:{
      t = jj_consume_token(IDENTIFICADOR);
String tipo = "error";
          try {
              tipo = tablaSimbolos.obtenerTipo(t.image);
          } catch (Exception e) {
              erroresSemanticos.add(e.getMessage());
          }
          n = new Nodo(t.image, tipo);
          pilaSemantica.push(n);
          {if ("" != null) return n;}
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo gramaticaEscribir() throws ParseException {Nodo n = new Nodo("Escribir"); Nodo hijo; Token t;
    try {
      jj_consume_token(ESCRIBIR);
      jj_consume_token(PARENIZQ);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VCAD:{
          t = jj_consume_token(VCAD);
n.agregarHijo(new Nodo(t.image, "string"));
          break;
          }
        case IDENTIFICADOR:{
          t = jj_consume_token(IDENTIFICADOR);
n.agregarHijo(new Nodo(t.image, "id"));
          break;
          }
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case CONCATENAR:{
            ;
            break;
            }
          default:
            jj_la1[5] = jj_gen;
            break label_3;
          }
          jj_consume_token(CONCATENAR);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case VCAD:{
            t = jj_consume_token(VCAD);
n.agregarHijo(new Nodo(t.image, "string"));
            break;
            }
          case IDENTIFICADOR:{
            t = jj_consume_token(IDENTIFICADOR);
n.agregarHijo(new Nodo(t.image, "id"));
            break;
            }
          default:
            jj_la1[6] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VCAD:
        case IDENTIFICADOR:{
          ;
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          break label_2;
        }
      }
      jj_consume_token(PARENDER);
      jj_consume_token(DELIMITADOR);
{if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo gramaticaLeer() throws ParseException {Token t; Nodo n = new Nodo("Leer");
    try {
      jj_consume_token(LEER);
      jj_consume_token(PARENIZQ);
      t = jj_consume_token(IDENTIFICADOR);
      jj_consume_token(PARENDER);
      jj_consume_token(DELIMITADOR);
n.agregarHijo(new Nodo(t.image, "id"));
            {if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo gramaticaSi() throws ParseException {Nodo n = new Nodo("Si (IF)"); Nodo cond, hijo, sino;
    try {
      jj_consume_token(SI);
      jj_consume_token(PARENIZQ);
      cond = condicion();
      jj_consume_token(PARENDER);
n.agregarHijo(cond);
      jj_consume_token(LLAVEIZQ);
      label_4:
      while (true) {
        hijo = Codigo();
n.agregarHijo(hijo);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BOOL:
        case VAR:
        case CONST:
        case FOR:
        case WHILE:
        case SI:
        case LEER:
        case ESCRIBIR:
        case VOID:
        case FUNC:
        case IDENTIFICADOR:{
          ;
          break;
          }
        default:
          jj_la1[8] = jj_gen;
          break label_4;
        }
      }
      jj_consume_token(LLAVEDER);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SINO:{
          ;
          break;
          }
        default:
          jj_la1[9] = jj_gen;
          break label_5;
        }
        sino = gramaticaSiNo();
n.agregarHijo(sino);
      }
{if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo gramaticaSiNo() throws ParseException {Nodo n = new Nodo("Sino (ELSE)"); Nodo hijo;
    try {
      jj_consume_token(SINO);
      jj_consume_token(LLAVEIZQ);
      label_6:
      while (true) {
        hijo = Codigo();
n.agregarHijo(hijo);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BOOL:
        case VAR:
        case CONST:
        case FOR:
        case WHILE:
        case SI:
        case LEER:
        case ESCRIBIR:
        case VOID:
        case FUNC:
        case IDENTIFICADOR:{
          ;
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          break label_6;
        }
      }
      jj_consume_token(LLAVEDER);
{if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo condicion() throws ParseException {Nodo izq, der, log; Token t;
    try {
      izq = valor();
      t = OperadoresComparadores();
      der = valor();
String tipoRes = verificarTipo(izq.tipo, der.tipo, t.image);
            if (!tipoRes.equals("error")) tipoRes = "bool"; // El resultado de una comparación es boolean
            Nodo raiz = new Nodo(t.image, tipoRes);
            raiz.agregarHijo(izq);
            raiz.agregarHijo(der);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case AND:
        case OR:
        case NOT:{
          ;
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          break label_7;
        }
        log = condicionLogicos();
raiz.agregarHijo(log);
      }
{if ("" != null) return raiz;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo condicionLogicos() throws ParseException {Nodo n; Token t; Nodo v1, v2; Token comp;
    try {
      t = OperadoresLogicos();
      v1 = valor();
      comp = OperadoresComparadores();
      v2 = valor();
Nodo raiz = new Nodo(t.image, "logico");
            Nodo comparisons = new Nodo(comp.image, "comparador");
            comparisons.agregarHijo(v1);
            comparisons.agregarHijo(v2);
            raiz.agregarHijo(comparisons);
            {if ("" != null) return raiz;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Token OperadoresLogicos() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AND:{
      t = jj_consume_token(AND);
{if ("" != null) return t;}
      break;
      }
    case OR:{
      t = jj_consume_token(OR);
{if ("" != null) return t;}
      break;
      }
    case NOT:{
      t = jj_consume_token(NOT);
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Token OperadoresComparadores() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IGUALDAD:{
      t = jj_consume_token(IGUALDAD);
{if ("" != null) return t;}
      break;
      }
    case DESIGUALDAD:{
      t = jj_consume_token(DESIGUALDAD);
{if ("" != null) return t;}
      break;
      }
    case MAYOR:{
      t = jj_consume_token(MAYOR);
{if ("" != null) return t;}
      break;
      }
    case MENOR:{
      t = jj_consume_token(MENOR);
{if ("" != null) return t;}
      break;
      }
    case MAYORIGUAL:{
      t = jj_consume_token(MAYORIGUAL);
{if ("" != null) return t;}
      break;
      }
    case MENORIGUAL:{
      t = jj_consume_token(MENORIGUAL);
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo gramaticaWhile() throws ParseException {Nodo n = new Nodo("While"); Nodo cond, hijo;
    try {
      jj_consume_token(WHILE);
      jj_consume_token(PARENIZQ);
      cond = condicion();
      jj_consume_token(PARENDER);
n.agregarHijo(cond);
      jj_consume_token(LLAVEIZQ);
      label_8:
      while (true) {
        hijo = Codigo();
n.agregarHijo(hijo);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BOOL:
        case VAR:
        case CONST:
        case FOR:
        case WHILE:
        case SI:
        case LEER:
        case ESCRIBIR:
        case VOID:
        case FUNC:
        case IDENTIFICADOR:{
          ;
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          break label_8;
        }
      }
      jj_consume_token(LLAVEDER);
{if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo gramaticaAsignacion() throws ParseException {Token t; Nodo e; Nodo n = new Nodo("Asignacion");
    try {
      t = jj_consume_token(IDENTIFICADOR);
      jj_consume_token(IGUAL);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTEROS:
      case NUMERODECIMAL:
      case VCAD:
      case IDENTIFICADOR:{
        e = operacionSimple();
        break;
        }
      case FUNC:{
        e = asignacionConFuncion();
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DELIMITADOR);
String tipoDestino = "error";
            try {
                tipoDestino = tablaSimbolos.obtenerTipo(t.image);
                verificarTipo(tipoDestino, e.tipo, "=");
            } catch (Exception e_sem) {
                erroresSemanticos.add(e_sem.getMessage());
            }
            n.valor = "Asignacion: " + t.image;
            n.tipo = tipoDestino;
            n.agregarHijo(e);

            // Sacamos el resultado final de la expresión de la pila para que no se acumule
            if (!pilaSemantica.isEmpty()) pilaSemantica.pop();

            {if ("" != null) return n;}
    } catch (ParseException e_arg) {
tabla.add(manejarErrorSintactico(e_arg));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo operacionSimple() throws ParseException {Nodo izq, der; Token t;
    try {
      izq = termino();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MAS:
        case MENOS:{
          ;
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MAS:{
          t = jj_consume_token(MAS);
          break;
          }
        case MENOS:{
          t = jj_consume_token(MENOS);
          break;
          }
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        der = termino();
// La Pila Semántica ya tiene los operandos (izq y der) en orden (izq, der)
                // Sacamos los dos últimos
                Nodo opDer = pilaSemantica.pop();
                Nodo opIzq = pilaSemantica.pop();

                String tipoRes = verificarTipo(opIzq.tipo, opDer.tipo, t.image);

                // Generamos cuádruplo y metemos el resultado T# en la pila
                Nodo raiz = pilaSemantica.generarCuadruplo(t.image, opIzq, opDer, tipoRes);
                raiz.agregarHijo(opIzq);
                raiz.agregarHijo(opDer);
                izq = raiz;
      }
{if ("" != null) return izq;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo termino() throws ParseException {Nodo izq, der; Token t;
    izq = valor();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:
      case DIV:
      case MOD:{
        ;
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:{
        t = jj_consume_token(MULT);
        break;
        }
      case DIV:{
        t = jj_consume_token(DIV);
        break;
        }
      case MOD:{
        t = jj_consume_token(MOD);
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      der = valor();
Nodo opDer = pilaSemantica.pop();
            Nodo opIzq = pilaSemantica.pop();

            String tipoRes = verificarTipo(opIzq.tipo, opDer.tipo, t.image);

            Nodo raiz = pilaSemantica.generarCuadruplo(t.image, opIzq, opDer, tipoRes);
            raiz.agregarHijo(opIzq);
            raiz.agregarHijo(der);
            izq = raiz;
    }
{if ("" != null) return izq;}
    throw new Error("Missing return statement in function");
}

  static final public Nodo gramaticaOperadorLogico() throws ParseException {Token t; Token id; Nodo cond; Nodo n = new Nodo("Asignacion Logica");
    try {
      jj_consume_token(BOOL);
      id = jj_consume_token(IDENTIFICADOR);
      jj_consume_token(IGUAL);
      cond = condicionLogico();
      jj_consume_token(DELIMITADOR);
n.valor = "Asignacion Logica: " + id.image;
            n.agregarHijo(cond);
            {if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo condicionLogico() throws ParseException {Nodo izq, der; Token t;
    try {
      izq = valor();
      t = OperadoresLogicos();
      der = valor();
Nodo raiz = new Nodo(t.image, "logico");
            raiz.agregarHijo(izq);
            raiz.agregarHijo(der);
            {if ("" != null) return raiz;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo gramaticaFor() throws ParseException {Nodo n = new Nodo("For"); Nodo cond, hijo;
    try {
      jj_consume_token(FOR);
      jj_consume_token(PARENIZQ);
      cond = condicionFor();
      jj_consume_token(PARENDER);
n.agregarHijo(cond);
      jj_consume_token(LLAVEIZQ);
      label_11:
      while (true) {
        hijo = Codigo();
n.agregarHijo(hijo);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BOOL:
        case VAR:
        case CONST:
        case FOR:
        case WHILE:
        case SI:
        case LEER:
        case ESCRIBIR:
        case VOID:
        case FUNC:
        case IDENTIFICADOR:{
          ;
          break;
          }
        default:
          jj_la1[20] = jj_gen;
          break label_11;
        }
      }
      jj_consume_token(LLAVEDER);
{if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo condicionFor() throws ParseException {Token id, id2, val, id3; String tipo; Token comp, inc; Nodo n = new Nodo("Condicion For"); Nodo val2;
    try {
      tipo = tipoDato();
      id = jj_consume_token(IDENTIFICADOR);
      jj_consume_token(IGUAL);
      val = jj_consume_token(ENTEROS);
      jj_consume_token(DELIMITADOR);
      id2 = jj_consume_token(IDENTIFICADOR);
      comp = OperadoresComparadores();
      val2 = valor();
      jj_consume_token(DELIMITADOR);
      inc = operadorIncDec();
      id3 = jj_consume_token(IDENTIFICADOR);
n.agregarHijo(new Nodo("Inicio: " + id.image + "=" + val.image, tipo));
            Nodo comparison = new Nodo(comp.image, "comparador");
            comparison.agregarHijo(new Nodo(id2.image, "id"));
            comparison.agregarHijo(val2);
            n.agregarHijo(comparison);
            n.agregarHijo(new Nodo("Paso: " + inc.image + id3.image));
            {if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Token operadorIncDec() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INC:{
      t = jj_consume_token(INC);
{if ("" != null) return t;}
      break;
      }
    case DEC:{
      t = jj_consume_token(DEC);
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo SentenciasFunciones() throws ParseException {Token id; String tipo; Nodo param = null, hijo, ret; Nodo n;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FUNC:{
        jj_consume_token(FUNC);
        tipo = tipoDato();
        id = jj_consume_token(IDENTIFICADOR);
        jj_consume_token(PARENIZQ);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFICADOR:{
          param = parametros();
          break;
          }
        default:
          jj_la1[22] = jj_gen;
          ;
        }
        jj_consume_token(PARENDER);
try {
                  tablaSimbolos.insertar(id.image, tipo); // Registrar retorno de la funcion
              } catch (Exception e_sem) {
                  erroresSemanticos.add(e_sem.getMessage());
              }
        jj_consume_token(LLAVEIZQ);
n = new Nodo("Funcion: " + id.image, tipo);
              if (param != null) n.agregarHijo(param);
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case BOOL:
          case VAR:
          case CONST:
          case FOR:
          case WHILE:
          case SI:
          case LEER:
          case ESCRIBIR:
          case VOID:
          case FUNC:
          case IDENTIFICADOR:{
            ;
            break;
            }
          default:
            jj_la1[23] = jj_gen;
            break label_12;
          }
          hijo = Codigo();
n.agregarHijo(hijo);
        }
        jj_consume_token(RETURN);
        ret = valor();
        jj_consume_token(DELIMITADOR);
        jj_consume_token(LLAVEDER);
        jj_consume_token(DELIMITADOR);
verificarTipo(tipo, ret.tipo, "return");
              Nodo retNode = new Nodo("Return", ret.tipo);
              retNode.agregarHijo(ret);
              n.agregarHijo(retNode);
              {if ("" != null) return n;}
        break;
        }
      case VOID:{
        jj_consume_token(VOID);
        id = jj_consume_token(IDENTIFICADOR);
        jj_consume_token(PARENIZQ);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFICADOR:{
          param = parametros();
          break;
          }
        default:
          jj_la1[24] = jj_gen;
          ;
        }
        jj_consume_token(PARENDER);
try {
                  tablaSimbolos.insertar(id.image, "void");
              } catch (Exception e_sem) {
                  erroresSemanticos.add(e_sem.getMessage());
              }
        jj_consume_token(LLAVEIZQ);
n = new Nodo("Procedimiento: " + id.image, "void");
              if (param != null) n.agregarHijo(param);
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case BOOL:
          case VAR:
          case CONST:
          case FOR:
          case WHILE:
          case SI:
          case LEER:
          case ESCRIBIR:
          case VOID:
          case FUNC:
          case IDENTIFICADOR:{
            ;
            break;
            }
          default:
            jj_la1[25] = jj_gen;
            break label_13;
          }
          hijo = Codigo();
n.agregarHijo(hijo);
        }
        jj_consume_token(LLAVEDER);
        jj_consume_token(DELIMITADOR);
{if ("" != null) return n;}
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo parametros() throws ParseException {Token id; String tipo; Nodo n = new Nodo("Parametros");
    try {
      id = jj_consume_token(IDENTIFICADOR);
      tipo = tipoDato();
n.agregarHijo(new Nodo(id.image, tipo));
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMA:{
          ;
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          break label_14;
        }
        jj_consume_token(COMA);
        id = jj_consume_token(IDENTIFICADOR);
        tipo = tipoDato();
n.agregarHijo(new Nodo(id.image, tipo));
      }
{if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo llamarFuncion() throws ParseException {Token id; Nodo v; Nodo n = new Nodo("Llamada Funcion");
    try {
      jj_consume_token(FUNC);
      id = jj_consume_token(IDENTIFICADOR);
n.valor = "Llamada: " + id.image;
      jj_consume_token(PARENIZQ);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTEROS:
      case NUMERODECIMAL:
      case VCAD:
      case IDENTIFICADOR:{
        v = valor();
n.agregarHijo(v);
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMA:{
            ;
            break;
            }
          default:
            jj_la1[28] = jj_gen;
            break label_15;
          }
          jj_consume_token(COMA);
          v = valor();
n.agregarHijo(v);
        }
        break;
        }
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      jj_consume_token(PARENDER);
      jj_consume_token(DELIMITADOR);
{if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static final public Nodo asignacionConFuncion() throws ParseException {Token id; Nodo v; Nodo n = new Nodo("Llamada Funcion");
    try {
      jj_consume_token(FUNC);
      id = jj_consume_token(IDENTIFICADOR);
String tipoRet = "error";
            try {
                tipoRet = tablaSimbolos.obtenerTipo(id.image);
            } catch (Exception e) {
                erroresSemanticos.add(e.getMessage());
            }
            n.valor = "Llamada: " + id.image;
            n.tipo = tipoRet;
      jj_consume_token(PARENIZQ);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTEROS:
      case NUMERODECIMAL:
      case VCAD:
      case IDENTIFICADOR:{
        v = valor();
n.agregarHijo(v);
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMA:{
            ;
            break;
            }
          default:
            jj_la1[30] = jj_gen;
            break label_16;
          }
          jj_consume_token(COMA);
          v = valor();
n.agregarHijo(v);
        }
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      jj_consume_token(PARENDER);
{if ("" != null) return n;}
    } catch (ParseException e) {
tabla.add(manejarErrorSintactico(e));
        {if ("" != null) return null;}
    }
    throw new Error("Missing return statement in function");
}

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AnalizadorAqheranTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[32];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x1a00,0x1a00,0x780,0xc0000000,0x0,0x0,0x0,0x0,0x1a00,0x0,0x1a00,0x700000,0x700000,0x3e800000,0x1a00,0xc0000000,0x6000,0x6000,0x38000,0x38000,0x1a00,0xc0000,0x0,0x1a00,0x0,0x1a00,0x0,0x0,0x0,0xc0000000,0x0,0xc0000000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x18801a6,0x18801a6,0x0,0x1000001,0x1000001,0x40000,0x1000001,0x1000001,0x18801a6,0x40,0x18801a6,0x0,0x0,0x0,0x18801a6,0x1800001,0x0,0x0,0x0,0x0,0x18801a6,0x0,0x1000000,0x18801a6,0x1000000,0x18801a6,0x880000,0x800,0x800,0x1000001,0x800,0x1000001,};
	}

  /** Constructor with InputStream. */
  public AnalizadorAqheran(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public AnalizadorAqheran(java.io.InputStream stream, String encoding) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser.  ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new AnalizadorAqheranTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public AnalizadorAqheran(java.io.Reader stream) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new AnalizadorAqheranTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new AnalizadorAqheranTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public AnalizadorAqheran(AnalizadorAqheranTokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(AnalizadorAqheranTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[58];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 32; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 58; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
